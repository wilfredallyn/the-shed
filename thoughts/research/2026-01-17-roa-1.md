---
date: 2026-01-17T15:01:27-08:00
researcher: Claude
git_commit: 9243cc1
branch: auto-fix-roa-1
repository: the-shed
bead: the-shed-roa.1
topic: "Core Logging Infrastructure - Existing Patterns"
tags: [research, codebase, logging, localStorage, state-management]
status: complete
last_updated: 2026-01-17
last_updated_by: claude
last_updated_note: "Added critical review"
review_status: reviewed
---

# Research: Core Logging Infrastructure

**Date**: 2026-01-17T15:01:27-08:00
**Researcher**: Claude
**Git Commit**: 9243cc1
**Branch**: auto-fix-roa-1
**Repository**: the-shed

## Research Question

Document existing patterns for state management, localStorage, history storage, mode lifecycle, and challenge data structures in the Piano Tutor app to inform session logging infrastructure.

## Pre-Research Verification

```bash
grep -n "sessionLog" index.html | head -5
# (no output - feature does not exist)
```

Confirmed: No `sessionLog` functionality exists in the codebase.

## Summary

- Each mode uses a consistent state variable pattern with prefix naming (e.g., `int_`, `ch_`, `iivi_`)
- History is stored in localStorage as JSON arrays, max 50 entries per mode
- Cumulative stats persist across sessions in separate localStorage keys
- Mode lifecycle follows: StartGame -> RunCountdown -> NextChallenge -> OnNoteOn -> EndGame
- Per-challenge stats are tracked in a `{prefix}_stats` object during gameplay
- Challenge timing uses `challengeStartTime = Date.now()` set in NextChallenge

## Detailed Findings

### State Variables Pattern

Each mode declares state variables with a consistent prefix pattern at the top of its section:

```javascript
// Line 4588-4602: INTERVALS MODE state variables
let int_isPlaying = false;
let int_challenge = null;
let int_usedChallenges = new Set();
let int_challengeStartTime = null;
let int_config = null;
let int_currentRound = 0;
let int_firstTryCorrect = 0;
let int_totalMistakes = 0;
let int_slowCount = 0;
let int_roundHadMistake = false;
let int_stats = {};
let int_allTimes = [];
let int_history = [];
let int_cumulativeStats = {};
```

### localStorage Patterns

Two types of data stored per mode:

**1. Game History** (`{modeKey}GameHistory`):
```javascript
// Line 4874
localStorage.setItem('intervalGameHistory', JSON.stringify(int_history));

// Line 4962-4963: Loading
const saved = localStorage.getItem('intervalGameHistory');
if (saved) { int_history = JSON.parse(saved); }
```

**2. Cumulative Stats** (`{modeKey}CumulativeStats`):
```javascript
// Line 4989
localStorage.setItem('intervalCumulativeStats', JSON.stringify(int_cumulativeStats));

// Line 4964-4965: Loading
const savedCumulative = localStorage.getItem('intervalCumulativeStats');
if (savedCumulative) { int_cumulativeStats = JSON.parse(savedCumulative); }
```

### History Entry Structure

Example from intervals mode (line 4863-4872):
```javascript
int_history.unshift({
    date: new Date().toISOString(),
    config: { ...int_config },
    score: int_firstTryCorrect,
    totalRounds: int_config.totalRounds,
    accuracy,    // calculated percentage
    avgTime,     // calculated average
    totalMistakes: int_totalMistakes,
    slowCount: int_slowCount,
    stats: JSON.parse(JSON.stringify(int_stats))  // deep copy
});
if (int_history.length > 50) int_history.pop();
```

### Cumulative Stats Structure

Example from intervals mode (line 4978-4989):
```javascript
function intUpdateCumulativeStats() {
    for (const [intervalName, data] of Object.entries(int_stats)) {
        if (!int_cumulativeStats[intervalName]) {
            int_cumulativeStats[intervalName] = { attempts: 0, firstTry: 0, totalTime: 0, slow: 0 };
        }
        int_cumulativeStats[intervalName].attempts += data.total;
        int_cumulativeStats[intervalName].firstTry += data.firstTry;
        int_cumulativeStats[intervalName].totalTime += data.times.reduce((a, b) => a + b, 0);
        int_cumulativeStats[intervalName].slow += data.slow || 0;
    }
    localStorage.setItem('intervalCumulativeStats', JSON.stringify(int_cumulativeStats));
}
```

### Mode Lifecycle Pattern

**1. StartGame** (line 4612-4678):
- Validates settings, initializes config
- Resets round counters and stats
- Hides settings, shows challenge display
- Calls `RunCountdown(3)`

**2. RunCountdown** (line 4680-4691):
- Displays countdown 3-2-1
- Sets `int_isPlaying = true` when countdown reaches 0
- Calls `NextChallenge()`

**3. NextChallenge** (line 4701-4775):
- Checks if game complete, calls EndGame if so
- Increments round counter
- Generates new challenge
- **CRITICAL**: Sets `challengeStartTime = Date.now()` (line 4767)
- Updates display with challenge prompt

**4. OnNoteOn** (line 4777-4827):
- Guards: `if (!int_isPlaying || !int_challenge) return`
- Calculates `responseTime = (Date.now() - int_challengeStartTime) / 1000`
- Tracks stats per challenge item in `int_stats[statKey]`
- On correct: advances to next challenge
- On incorrect: marks mistake, awaits correct answer

**5. EndGame** (line 4855-4878):
- Sets `int_isPlaying = false`
- Calculates accuracy and avgTime
- Creates history entry with all stats
- Saves to localStorage
- Calls UpdateCumulativeStats
- Shows game complete display

### Per-Challenge Stats Object

During gameplay, stats are tracked per challenge item (line 4794-4809):
```javascript
if (!int_stats[statKey]) {
    int_stats[statKey] = { firstTry: 0, total: 0, times: [], slow: 0 };
}
int_stats[statKey].total++;

// On correct answer without prior mistake:
int_stats[statKey].firstTry++;
int_stats[statKey].times.push(responseTime);

// If slow (>2s):
int_stats[statKey].slow++;
```

### Challenge Object Structure

Varies by mode:

**Intervals** (line 4709-4755):
```javascript
int_challenge = {
    interval,           // semitones (e.g., 3 for minor 3rd)
    direction: dir,     // 'up' or 'down'
    startMidi,          // MIDI note number
    targetMidi          // expected answer MIDI
};
```

**Chords** (line 5065):
```javascript
ch_challenge = {
    root: 0-11,
    type: 'maj7'|'min7'|'dom7',
    name: 'C maj7',
    requiredPitchClasses: Set
};
```

**ii-V-I** (line 5529):
```javascript
iivi_challenge = {
    key: 0-11,
    chords: [{root, type, pitchClasses}, ...],
    currentStep: 0-2
};
```

### Timing Constants

From CLAUDE.md:
| Mode Type | Fast | Medium | Slow |
|-----------|------|--------|------|
| Chords/voicings | <2s | 2-4s | >4s |
| Scales (8 notes) | <4s | 4-6s | >6s |
| Single notes | <1s | 1-2s | >2s |

### MIDI Handler Guard Pattern

Required guards to prevent timing bugs (from CLAUDE.md):
```javascript
function {prefix}OnNoteOn(midi) {
    if (!{prefix}_isPlaying || !{prefix}_challenge || !{prefix}_challengeStartTime) return;
    // ... rest of handler
}
```

## Code References

- `index.html:4588-4602` - Intervals mode state variable declarations
- `index.html:4612-4678` - intStartGame() implementation
- `index.html:4680-4691` - intRunCountdown() implementation
- `index.html:4701-4775` - intNextChallenge() implementation
- `index.html:4777-4827` - intOnNoteOn() MIDI handler
- `index.html:4855-4878` - intEndGame() with history storage
- `index.html:4961-4976` - intLoadHistory() and intClearHistory()
- `index.html:4978-4989` - intUpdateCumulativeStats()
- `index.html:5064-5078` - Chords mode state variables (similar pattern)
- `index.html:5528-5543` - ii-V-I mode state variables (similar pattern)

## Architecture Documentation

### Current Data Flow

```
StartGame
    |
    v
RunCountdown(3) -> 2 -> 1 -> 0
    |
    v
NextChallenge [sets challengeStartTime]
    |
    v
OnNoteOn [calculates responseTime, updates stats]
    |
    +--> incorrect: await retry
    |
    +--> correct: setTimeout -> NextChallenge
              |
              v (when rounds complete)
          EndGame
              |
              v
          history.unshift(gameRecord)
          localStorage.setItem(...)
          UpdateCumulativeStats()
```

### Storage Keys by Mode

| Mode | History Key | Cumulative Key |
|------|-------------|----------------|
| Intervals | intervalGameHistory | intervalCumulativeStats |
| 7th Chords | chordsGameHistory | chordsCumulativeStats |
| ii-V-I | iiviGameHistory | iiviCumulativeStats |
| Scales | scGameHistory | scCumulativeStats |
| Extensions | extGameHistory | extCumulativeStats |
| Altered | altGameHistory | altCumulativeStats |
| Advanced | advGameHistory | advCumulativeStats |
| Minor ii-V-i | minorIiviGameHistory | miiviCumulativeStats |

## Open Questions

1. Does session logging need to capture individual note events or just challenge-level data?
2. Should session logs persist indefinitely or follow the 50-entry limit pattern?
3. Will session logs be per-mode or cross-mode aggregate?

---

## Review: 2026-01-17

**Reviewer**: claude
**Review commit**: 9243cc1
**Research commit**: 9243cc1
**Staleness**: 0 commits since research

### Validation Summary

| Metric | Score | Notes |
|--------|-------|-------|
| Accuracy | 90% | Minor inaccuracies in history limits and guard patterns |
| Completeness | 85% | Core patterns documented, some modes missing |
| Actionability | 95% | Sufficient for implementation planning |
| Currency | 100% | Current with HEAD |
| Relevance | 90% | Focused on required patterns, minimal tangents |

**Overall Assessment**: Ready for implementation

### Code Reference Validation

| Reference | Status | Notes |
|-----------|--------|-------|
| `index.html:4588-4602` | ACCURATE | State variables match exactly |
| `index.html:4612-4678` | ACCURATE | intStartGame() implementation correct |
| `index.html:4680-4691` | SHIFTED | Function ends at 4692, minor shift |
| `index.html:4701-4775` | ACCURATE | intNextChallenge() matches |
| `index.html:4777-4827` | ACCURATE | intOnNoteOn() matches |
| `index.html:4855-4878` | ACCURATE | intEndGame() matches |
| `index.html:4961-4976` | ACCURATE | History functions match |
| `index.html:4978-4989` | SHIFTED | Function ends at 4990, minor shift |
| `index.html:5064-5078` | ACCURATE | Chords state variables match |
| `index.html:5528-5543` | SHIFTED | ii-V-I variables at 5528-5544 |

### Identified Gaps

#### Critical (Must Address)
None - research is sufficient for implementation.

#### Minor (Nice to Have)
- Research documents 8 modes in storage key table but app has 17+ modes. Session logging needs to handle all modes, not just the documented subset.
- Guard pattern documentation shows inconsistency: CLAUDE.md recommends triple-guard but older modes (1-13) use only double-guard. Newer modes (14+) use triple-guard. Research should clarify which pattern to follow.

### Incorrect or Outdated Claims

- **Line 39**: "max 50 entries per mode" - Actual limits vary by mode: 50 (intervals, chords, ii-V-I, scales, advanced, minor ii-V-i), 20 (pent, bebop, tritone, upper, freestyle), 10 (extv). Session logging implementation should not assume 50.
- **Line 150**: Guards described as `if (!int_isPlaying || !int_challenge) return` - Actual implementation does not early return, it highlights key instead. The guard pattern varies between modes.
- **Line 223-231**: Research quotes CLAUDE.md triple-guard but actual older modes only use double-guard (`!isPlaying || !challenge`). Only modes 14+ use the recommended triple-guard with `challengeStartTime`.

### Recommendations

1. For session logging, use the triple-guard pattern as documented in CLAUDE.md regardless of what existing modes do.
2. Session logging history limits should be configurable or use the most common pattern (50 entries).
3. The storage key naming table should be referenced as representative examples, not exhaustive list.

### Files Changed Since Research

None - research is current with HEAD (9243cc1).
