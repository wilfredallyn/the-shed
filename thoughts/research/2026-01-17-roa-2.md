---
date: 2026-01-17
author: claude
bead: the-shed-roa.2
topic: "MIDI Handler Instrumentation Research"
tags: [research, session-logging, midi, instrumentation]
---

# MIDI Handler Instrumentation Research

## Task Context

Add logging calls to the MIDI handler to capture every note played during practice sessions.

**Scope:**
- Modify handleMIDI() around line 4455
- Call sessionLogRecordEvent on noteOn/noteOff
- Include guards for logging enabled and session active
- Calculate isCorrect flag based on expected pitch classes

**Dependency:** Core logging infrastructure (the-shed-roa.1)

## handleMIDI() Current Structure

**Location:** `index.html:4455-4508`

```javascript
function handleMIDI(msg) {
    const [cmd, note, vel] = msg.data;
    if ((cmd & 0xF0) === 144 && vel > 0) {
        // NOTE ON
        heldNotes.add(note);
        updateChordIdentifier();
        highlightKey('previewPianoSvg', note, 'key-active');
        // Mode-specific handlers (20 modes)
        if (currentMode === 'intervals') intOnNoteOn(note);
        else if (currentMode === 'chords') chOnNoteOn(note);
        // ... 18 more mode handlers
    } else if ((cmd & 0xF0) === 128 || ((cmd & 0xF0) === 144 && vel === 0)) {
        // NOTE OFF
        heldNotes.delete(note);
        updateChordIdentifier();
        highlightKey('previewPianoSvg', note, 'key-active', false);
        // Mode-specific handlers (20 modes)
        if (currentMode === 'intervals') intOnNoteOff(note);
        else if (currentMode === 'chords') chOnNoteOff(note);
        // ... 18 more mode handlers
    }
}
```

**Key Observations:**
- MIDI command 144 (0x90) with vel > 0 = noteOn
- MIDI command 128 (0x80) OR 144 with vel = 0 = noteOff
- `note` variable contains the raw MIDI note number (0-127)
- `vel` contains velocity (0-127)
- Mode-specific handlers are called AFTER the generic operations

## sessionLogRecordEvent Function Signature

**From the-shed-roa.1 plan (lines 154-167):**

```javascript
function sessionLogRecordEvent(type, midi, velocity) {
    if (!sessionLogEnabled || !currentSessionLog || !currentRoundLog || !roundStartTime) return;

    const event = {
        type: type,  // 'noteOn' or 'noteOff'
        midi: midi,
        pitchClass: midi % 12,
        velocity: velocity || 0,
        offsetMs: Date.now() - roundStartTime
    };

    currentRoundLog.events.push(event);
}
```

**Parameters:**
- `type`: String - 'noteOn' or 'noteOff'
- `midi`: Number - MIDI note number (0-127)
- `velocity`: Number - velocity (0-127), optional

**Guards (built into function):**
- `sessionLogEnabled` - global boolean
- `currentSessionLog` - non-null when session active
- `currentRoundLog` - non-null when round in progress
- `roundStartTime` - timestamp when round started

## Expected Pitch Classes: How Determined

The `expectedPitchClasses` are stored in `currentRoundLog.expectedPitchClasses` (set by `sessionLogStartRound(challenge)` when a new round begins).

To calculate `isCorrect` in handleMIDI:

```javascript
const isCorrect = currentRoundLog &&
    currentRoundLog.expectedPitchClasses &&
    currentRoundLog.expectedPitchClasses.includes(note % 12);
```

**Mode-specific challenge structures (how pitch classes are derived):**

| Mode | Challenge Field | Pitch Class Extraction |
|------|-----------------|------------------------|
| intervals | `targetMidi` | `targetMidi % 12` |
| chords | `requiredPitchClasses` (Set) | `Array.from(set)` |
| ii-V-I | `chords[currentStep].pitchClasses` | `Array.from(set)` |
| scales | `scaleNotes[currentNoteIndex]` | `note % 12` |
| tritone | `fullPitchClasses` or `shellPitchClasses` | `Array.from(set)` |
| voiceleading | `targetChord.pitchClasses` | `Array.from(set)` |

The normalizer in roa.1 handles all these via `sessionLogExtractExpectedPitchClasses()`.

## Implementation Pattern

**Insert logging calls in handleMIDI after the generic operations but before mode-specific handlers:**

```javascript
function handleMIDI(msg) {
    const [cmd, note, vel] = msg.data;
    if ((cmd & 0xF0) === 144 && vel > 0) {
        // NOTE ON
        heldNotes.add(note);
        updateChordIdentifier();
        highlightKey('previewPianoSvg', note, 'key-active');

        // Session logging (only when enabled and round active)
        if (sessionLogEnabled && currentRoundLog) {
            const isCorrect = currentRoundLog.expectedPitchClasses &&
                currentRoundLog.expectedPitchClasses.includes(note % 12);
            sessionLogRecordEvent('noteOn', note, vel, isCorrect);
        }

        // Mode-specific handlers...
    } else if ((cmd & 0xF0) === 128 || ((cmd & 0xF0) === 144 && vel === 0)) {
        // NOTE OFF
        heldNotes.delete(note);
        updateChordIdentifier();
        highlightKey('previewPianoSvg', note, 'key-active', false);

        // Session logging (only when enabled and round active)
        if (sessionLogEnabled && currentRoundLog) {
            sessionLogRecordEvent('noteOff', note, vel);
        }

        // Mode-specific handlers...
    }
}
```

**Note on isCorrect for noteOff:** The plan's `sessionLogRecordEvent` doesn't include an `isCorrect` parameter. Need to decide:
1. Modify sessionLogRecordEvent to accept optional isCorrect
2. Only track isCorrect on noteOn events (more logical since noteOn is when you "play" a note)

Recommendation: Only calculate isCorrect for noteOn events. NoteOff just marks the release.

## Guard Conditions Analysis

The `sessionLogRecordEvent` function already guards against:
- `!sessionLogEnabled` - logging disabled
- `!currentSessionLog` - no session active
- `!currentRoundLog` - no round in progress
- `!roundStartTime` - round not started (countdown phase)

**Additional guard in handleMIDI:**
The outer `if (sessionLogEnabled && currentRoundLog)` provides early exit optimization so we don't compute isCorrect when logging is disabled.

## Modification Required to sessionLogRecordEvent

The current signature is `sessionLogRecordEvent(type, midi, velocity)`. To include isCorrect:

**Option A: Add parameter**
```javascript
function sessionLogRecordEvent(type, midi, velocity, isCorrect) {
    // ...
    const event = {
        type: type,
        midi: midi,
        pitchClass: midi % 12,
        velocity: velocity || 0,
        offsetMs: Date.now() - roundStartTime,
        isCorrect: isCorrect !== undefined ? isCorrect : null
    };
}
```

**Option B: Compute inside function**
```javascript
function sessionLogRecordEvent(type, midi, velocity) {
    // ...
    const pitchClass = midi % 12;
    const isCorrect = type === 'noteOn' && currentRoundLog.expectedPitchClasses
        ? currentRoundLog.expectedPitchClasses.includes(pitchClass)
        : null;

    const event = {
        type: type,
        midi: midi,
        pitchClass: pitchClass,
        velocity: velocity || 0,
        offsetMs: Date.now() - roundStartTime,
        isCorrect: isCorrect
    };
}
```

**Recommendation: Option B** - keeps handleMIDI simpler, encapsulates isCorrect logic in one place.

## Key Findings Summary

1. **handleMIDI location**: Line 4455-4508 in index.html
2. **sessionLogRecordEvent signature**: `(type, midi, velocity)` - needs modification to include isCorrect
3. **isCorrect calculation**: Compare `midi % 12` against `currentRoundLog.expectedPitchClasses`
4. **Guards needed**: `sessionLogEnabled && currentRoundLog` for early exit in handleMIDI
5. **Insertion point**: After generic operations, before mode-specific handlers

## Files to Modify

1. `index.html` - handleMIDI function (lines 4455-4508)

## Dependency Verification

This task depends on roa.1 (Core Logging Infrastructure) which must provide:
- [x] `sessionLogEnabled` global variable
- [x] `currentRoundLog` global variable with `expectedPitchClasses` array
- [x] `sessionLogRecordEvent(type, midi, velocity)` function

**Note:** The sessionLogRecordEvent function signature may need modification to support isCorrect, or the function can compute it internally.
