---
date: 2026-01-18
author: claude
bead: the-shed-roa.8
topic: "CSV Export Functions Research"
tags: [research, session-logging, csv, export]
status: complete
---

# CSV Export Functions Research

## Task Context

Implement two CSV export functions for session logging:
1. `exportSessionLogSummaryCSV()` - one row per round
2. `exportSessionLogDetailedCSV()` - one row per MIDI event

**Dependency:** Core logging infrastructure (the-shed-roa.1)

## Session Log Data Structure (from roa.1)

### Global State

```javascript
var sessionLogSessions = [];     // Array of all completed sessions
var currentSessionLog = null;    // Current active session
var currentRoundLog = null;      // Current active round
```

### Session Structure

From `sessionLogStartSession()` and `sessionLogEndSession()`:

```javascript
{
    mode: string,           // e.g., 'chords', 'intervals'
    config: object,         // mode-specific settings
    startTime: number,      // Date.now() at session start
    endTime: number,        // Date.now() at session end
    durationMs: number,     // Calculated duration
    rounds: []              // Array of round objects
}
```

### Round Structure

From `sessionLogStartRound()` and `sessionLogEndRound()`:

```javascript
{
    challenge: object,              // Mode-specific challenge data
    expectedPitchClasses: number[], // Array of pitch classes (0-11)
    events: [],                     // Array of MIDI events
    startTime: number,              // Round start timestamp
    endTime: number,                // Round end timestamp
    result: object,                 // Mode-specific result data
    durationMs: number              // Calculated duration
}
```

### Event Structure

From `sessionLogRecordEvent()`:

```javascript
{
    type: string,       // 'noteOn' or 'noteOff'
    midi: number,       // MIDI note number (0-127)
    pitchClass: number, // midi % 12 (0-11)
    velocity: number,   // MIDI velocity (0-127)
    offsetMs: number,   // Time since round start
    isCorrect: boolean|null // null for noteOff events
}
```

## Existing Patterns

### Note Name Lookup

From `session-log-debug.js:118`:

```javascript
const NOTE_NAMES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
```

### MIDI to Note Name + Octave

From `session-log-debug.js:134`:

```javascript
const noteName = NOTE_NAMES[last.midi % 12] + Math.floor(last.midi / 12 - 1);
// Example: midi 60 -> C4
```

### JSON Stringify for Storage

From `session-logging.js:188`:

```javascript
localStorage.setItem('sessionLogData', JSON.stringify(sessionLogSessions));
```

## No Existing CSV/Download Utilities

Grep search for `download|blob|URL.createObjectURL` found no results in JS files - only references in spec docs. This means:

1. CSV export functions need to implement download from scratch
2. Standard browser pattern needed: Blob -> createObjectURL -> anchor click

## CSV Export Implementation Patterns

### Standard Browser Download Pattern

```javascript
function downloadCSV(content, filename) {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
```

### CSV Escaping Requirements

Values containing commas, quotes, or newlines must be escaped:

```javascript
function escapeCSV(value) {
    if (value === null || value === undefined) return '';
    const str = String(value);
    // Escape if contains comma, quote, or newline
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}
```

### Date Formatting for Filenames

```javascript
const date = new Date().toISOString().split('T')[0]; // '2026-01-18'
const filename = `piano-tutor-summary-${date}.csv`;
```

## Required Column Mappings

### Summary CSV (one row per round)

| Column | Source |
|--------|--------|
| session_id | `sessions.indexOf(session)` or `session.startTime` |
| mode | `session.mode` |
| config | `JSON.stringify(session.config)` |
| round_num | `rounds.indexOf(round) + 1` |
| challenge_prompt | `round.challenge.prompt` or serialize challenge |
| expected_notes | `round.expectedPitchClasses.map(p => NOTE_NAMES[p]).join(' ')` |
| response_ms | `round.durationMs` |
| correct | `round.result.correct` or derive from events |
| mistakes | `round.result.mistakes` or count incorrect noteOn events |
| slow | `round.result.slow` or derive from durationMs |

### Detailed CSV (one row per MIDI event)

| Column | Source |
|--------|--------|
| session_id | `sessions.indexOf(session)` or `session.startTime` |
| mode | `session.mode` |
| round_num | `rounds.indexOf(round) + 1` |
| challenge_prompt | `round.challenge.prompt` |
| event_type | `event.type` ('noteOn' or 'noteOff') |
| midi_note | `event.midi` |
| note_name | `NOTE_NAMES[event.midi % 12]` |
| octave | `Math.floor(event.midi / 12 - 1)` |
| offset_ms | `event.offsetMs` |
| is_correct | `event.isCorrect` |
| round_result | `round.result.correct ? 'correct' : 'incorrect'` |

## Challenge Prompt Extraction

The challenge object varies by mode. Common patterns:

```javascript
function getChallengePrompt(challenge) {
    // Direct prompt property
    if (challenge.prompt) return challenge.prompt;

    // Interval mode
    if (challenge.intervalName) return challenge.intervalName;

    // Chord mode
    if (challenge.chordName) return challenge.chordName;

    // Scale mode
    if (challenge.scaleName) return challenge.scaleName;

    // ii-V-I mode
    if (challenge.key && challenge.chord) return `${challenge.key} ${challenge.chord}`;

    // Fallback
    return JSON.stringify(challenge);
}
```

## Result Data Availability

The `round.result` object is populated by mode handlers via `sessionLogEndRound(result)`. Based on roa.2 research, common result properties include:

- `correct`: boolean - first-try correct
- `responseTimeMs` or `durationMs`: timing
- `mistakes`: count of wrong notes
- `slow`: boolean - exceeded threshold

If result properties are missing, they can be derived:
- `mistakes`: count events where `type === 'noteOn' && isCorrect === false`
- `slow`: check if `round.durationMs > threshold` (2000ms for chords, 4000ms for scales)

## Session ID Strategy

Options for unique session identification:
1. Array index (simple but changes if sessions deleted)
2. `session.startTime` (unique timestamp, sortable)
3. Generated UUID (most robust but adds complexity)

Recommendation: Use `session.startTime` as session_id - it's unique, already available, and meaningful for analysis.

## Implementation Plan

### exportSessionLogSummaryCSV()

```javascript
function exportSessionLogSummaryCSV() {
    const NOTE_NAMES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const headers = ['session_id', 'mode', 'config', 'round_num', 'challenge_prompt',
                     'expected_notes', 'response_ms', 'correct', 'mistakes', 'slow'];

    const rows = [headers.join(',')];

    sessionLogSessions.forEach(session => {
        const sessionId = session.startTime;
        const config = escapeCSV(JSON.stringify(session.config));

        session.rounds.forEach((round, roundIdx) => {
            const prompt = escapeCSV(getChallengePrompt(round.challenge));
            const expected = round.expectedPitchClasses
                ? round.expectedPitchClasses.map(p => NOTE_NAMES[p]).join(' ')
                : '';
            const responseMs = round.durationMs || 0;
            const correct = round.result?.correct ?? '';
            const mistakes = round.result?.mistakes ?? countMistakes(round.events);
            const slow = round.result?.slow ?? '';

            rows.push([
                sessionId, session.mode, config, roundIdx + 1, prompt,
                expected, responseMs, correct, mistakes, slow
            ].join(','));
        });
    });

    const csv = rows.join('\n');
    const date = new Date().toISOString().split('T')[0];
    downloadCSV(csv, `piano-tutor-summary-${date}.csv`);
}
```

### exportSessionLogDetailedCSV()

```javascript
function exportSessionLogDetailedCSV() {
    const NOTE_NAMES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const headers = ['session_id', 'mode', 'round_num', 'challenge_prompt', 'event_type',
                     'midi_note', 'note_name', 'octave', 'offset_ms', 'is_correct', 'round_result'];

    const rows = [headers.join(',')];

    sessionLogSessions.forEach(session => {
        const sessionId = session.startTime;

        session.rounds.forEach((round, roundIdx) => {
            const prompt = escapeCSV(getChallengePrompt(round.challenge));
            const roundResult = round.result?.correct ? 'correct' : 'incorrect';

            round.events.forEach(event => {
                const noteName = NOTE_NAMES[event.midi % 12];
                const octave = Math.floor(event.midi / 12 - 1);

                rows.push([
                    sessionId, session.mode, roundIdx + 1, prompt, event.type,
                    event.midi, noteName, octave, event.offsetMs,
                    event.isCorrect ?? '', roundResult
                ].join(','));
            });
        });
    });

    const csv = rows.join('\n');
    const date = new Date().toISOString().split('T')[0];
    downloadCSV(csv, `piano-tutor-detailed-${date}.csv`);
}
```

## Helper Functions Needed

```javascript
function escapeCSV(value) {
    if (value === null || value === undefined) return '';
    const str = String(value);
    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return '"' + str.replace(/"/g, '""') + '"';
    }
    return str;
}

function getChallengePrompt(challenge) {
    if (!challenge) return '';
    if (challenge.prompt) return challenge.prompt;
    if (challenge.intervalName) return challenge.intervalName;
    if (challenge.chordName) return challenge.chordName;
    return JSON.stringify(challenge);
}

function countMistakes(events) {
    if (!events) return 0;
    return events.filter(e => e.type === 'noteOn' && e.isCorrect === false).length;
}

function downloadCSV(content, filename) {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}
```

## File Location

Add to `session-logging.js` after `sessionLogClear()` function (around line 224).

## Testing Strategy

1. Enable session logging
2. Play a short game (6 rounds) in chords mode
3. Call `exportSessionLogSummaryCSV()` and verify:
   - File downloads with correct name
   - Opens in spreadsheet software
   - Has correct columns
   - Round count matches game
4. Call `exportSessionLogDetailedCSV()` and verify:
   - More rows than summary (one per MIDI event)
   - Note names and octaves correct
   - `isCorrect` flags match expected notes
5. Test with challenge prompts containing commas (e.g., "F# Maj7")
