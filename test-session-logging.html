<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Logging Tests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #4ade80; }
        h2 { color: #60a5fa; margin-top: 30px; }
        .test {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .pass { background: #166534; }
        .fail { background: #991b1b; }
        .summary {
            margin-top: 30px;
            padding: 20px;
            background: #16213e;
            border-radius: 8px;
        }
        .summary.all-pass { border: 2px solid #4ade80; }
        .summary.has-fails { border: 2px solid #f87171; }
        pre {
            background: #0f0f1a;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        .instructions {
            background: #1e3a5f;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Session Logging Tests</h1>

    <div class="instructions">
        <strong>How to use:</strong> Just open this file in your browser.
        It automatically loads <code>session-logging.js</code> and runs all tests.
    </div>

    <div id="results"></div>
    <div id="summary" class="summary"></div>

    <!-- Load the session logging code -->
    <script src="session-logging.js"></script>

    <script>
        // Simple test framework
        const results = [];

        function test(name, fn) {
            try {
                fn();
                results.push({ name, status: 'pass' });
            } catch (e) {
                results.push({ name, status: 'fail', error: e.message });
            }
        }

        function assert(condition, message) {
            if (!condition) throw new Error(message || 'Assertion failed');
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
            }
        }

        function assertType(value, type, message) {
            if (typeof value !== type) {
                throw new Error(message || `Expected type ${type}, got ${typeof value}`);
            }
        }

        // Reset state before tests
        function resetState() {
            localStorage.removeItem('sessionLogData');
            sessionLogEnabled = false;
            sessionLogSessions = [];
            currentSessionLog = null;
            currentRoundLog = null;
            roundStartTime = null;
        }

        resetState();

        // ==================== TESTS ====================

        test('Global variables exist', () => {
            assertType(sessionLogEnabled, 'boolean', 'sessionLogEnabled should be boolean');
            assert(Array.isArray(sessionLogSessions), 'sessionLogSessions should be array');
        });

        test('Functions exist', () => {
            assertType(sessionLogStartSession, 'function');
            assertType(sessionLogStartRound, 'function');
            assertType(sessionLogRecordEvent, 'function');
            assertType(sessionLogEndRound, 'function');
            assertType(sessionLogEndSession, 'function');
            assertType(sessionLogExtractExpectedPitchClasses, 'function');
            assertType(sessionLogSaveToStorage, 'function');
            assertType(sessionLogLoadFromStorage, 'function');
            assertType(sessionLogClear, 'function');
        });

        test('sessionLogStartSession creates session object', () => {
            resetState();
            sessionLogEnabled = true;
            sessionLogStartSession('chords', { rounds: 12, type: 'major' });

            assert(currentSessionLog !== null, 'currentSessionLog should exist');
            assertEqual(currentSessionLog.mode, 'chords');
            assertEqual(currentSessionLog.config.rounds, 12);
            assert(currentSessionLog.startTime > 0, 'startTime should be set');
            assert(Array.isArray(currentSessionLog.rounds), 'rounds should be array');
        });

        test('sessionLogStartRound creates round object', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'chords', rounds: [], startTime: Date.now() };

            sessionLogStartRound({ prompt: 'C Major', requiredPitchClasses: new Set([0, 4, 7]) });

            assert(currentRoundLog !== null, 'currentRoundLog should exist');
            assertEqual(currentRoundLog.challenge.prompt, 'C Major');
            assert(Array.isArray(currentRoundLog.events), 'events should be array');
            assert(roundStartTime !== null, 'roundStartTime should be set');
        });

        test('sessionLogRecordEvent adds events with timing', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'chords', rounds: [], startTime: Date.now() };
            currentRoundLog = {
                challenge: { prompt: 'C' },
                expectedPitchClasses: [0, 4, 7],
                events: [],
                startTime: Date.now()
            };
            roundStartTime = Date.now();

            sessionLogRecordEvent('noteOn', 60, 100);
            sessionLogRecordEvent('noteOn', 64, 90);

            assertEqual(currentRoundLog.events.length, 2);
            assertEqual(currentRoundLog.events[0].type, 'noteOn');
            assertEqual(currentRoundLog.events[0].midi, 60);
            assertEqual(currentRoundLog.events[0].velocity, 100);
            assert(currentRoundLog.events[0].offsetMs >= 0, 'offsetMs should be non-negative');
        });

        test('sessionLogRecordEvent marks correct notes', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'chords', rounds: [], startTime: Date.now() };
            currentRoundLog = {
                challenge: { prompt: 'C' },
                expectedPitchClasses: [0, 4, 7],
                events: [],
                startTime: Date.now()
            };
            roundStartTime = Date.now();

            sessionLogRecordEvent('noteOn', 60, 100);  // C (pitch class 0) - correct
            sessionLogRecordEvent('noteOn', 61, 100);  // C# (pitch class 1) - wrong

            assertEqual(currentRoundLog.events[0].isCorrect, true, 'C should be correct');
            assertEqual(currentRoundLog.events[1].isCorrect, false, 'C# should be incorrect');
        });

        test('sessionLogRecordEvent includes pitchClass', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'chords', rounds: [], startTime: Date.now() };
            currentRoundLog = {
                challenge: { prompt: 'C' },
                expectedPitchClasses: [0, 4, 7],
                events: [],
                startTime: Date.now()
            };
            roundStartTime = Date.now();

            sessionLogRecordEvent('noteOn', 72, 100);  // C5 (pitch class 0)

            assertEqual(currentRoundLog.events[0].pitchClass, 0, 'pitchClass should be 0 for C');
        });

        test('sessionLogEndRound closes round with results', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'chords', rounds: [], startTime: Date.now() };
            currentRoundLog = {
                challenge: { prompt: 'C' },
                expectedPitchClasses: [0, 4, 7],
                events: [{ type: 'noteOn', midi: 60 }],
                startTime: Date.now() - 1500
            };
            roundStartTime = Date.now() - 1500;

            sessionLogEndRound({ responseTime: 1500, isFirstTry: true });

            assertEqual(currentSessionLog.rounds.length, 1);
            assertEqual(currentSessionLog.rounds[0].result.isFirstTry, true);
            assert(currentSessionLog.rounds[0].durationMs > 0, 'durationMs should be set');
            assert(currentRoundLog === null, 'currentRoundLog should be cleared');
            assert(roundStartTime === null, 'roundStartTime should be cleared');
        });

        test('sessionLogEndSession saves to storage', () => {
            resetState();
            sessionLogEnabled = true;
            sessionLogSessions = [];
            currentSessionLog = {
                mode: 'chords',
                rounds: [{ challenge: {}, events: [], result: { isFirstTry: true } }],
                startTime: Date.now() - 5000,
                config: { rounds: 12 }
            };

            sessionLogEndSession();

            assertEqual(sessionLogSessions.length, 1);
            assert(sessionLogSessions[0].endTime > 0, 'endTime should be set');
            assert(sessionLogSessions[0].durationMs > 0, 'durationMs should be set');

            const stored = JSON.parse(localStorage.getItem('sessionLogData'));
            assert(stored !== null, 'Data should be in localStorage');
            assertEqual(stored.length, 1);
        });

        test('sessionLogExtractExpectedPitchClasses handles requiredPitchClasses Set', () => {
            const result = sessionLogExtractExpectedPitchClasses({
                name: 'C Major 7',
                requiredPitchClasses: new Set([0, 4, 7, 11])
            });

            assert(Array.isArray(result), 'should return array');
            assertEqual(result.length, 4);
            assert(result.includes(0), 'should include C');
            assert(result.includes(4), 'should include E');
        });

        test('sessionLogExtractExpectedPitchClasses handles targetMidi', () => {
            const result = sessionLogExtractExpectedPitchClasses({
                name: 'Major 3rd',
                targetMidi: 64  // E4
            });

            assert(Array.isArray(result), 'should return array');
            assertEqual(result.length, 1);
            assertEqual(result[0], 4, 'should be pitch class 4 (E)');
        });

        test('sessionLogExtractExpectedPitchClasses handles direct array', () => {
            const result = sessionLogExtractExpectedPitchClasses({
                expectedPitchClasses: [0, 2, 4, 5, 7, 9, 11]
            });

            assertEqual(result.length, 7);
        });

        test('sessionLogExtractExpectedPitchClasses returns null for unknown format', () => {
            const result = sessionLogExtractExpectedPitchClasses({
                someOtherProperty: 'value'
            });

            assertEqual(result, null);
        });

        test('Logging disabled does nothing', () => {
            resetState();
            sessionLogEnabled = false;
            currentSessionLog = null;

            sessionLogStartSession('chords', {});

            assert(currentSessionLog === null, 'Should not create session when disabled');
        });

        test('Events not recorded when no active round', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'test', rounds: [] };
            currentRoundLog = null;
            roundStartTime = null;

            // Should not throw
            sessionLogRecordEvent('noteOn', 60, 100);

            // No crash = pass
            assert(true);
        });

        test('Events not recorded when roundStartTime is null', () => {
            resetState();
            sessionLogEnabled = true;
            currentSessionLog = { mode: 'test', rounds: [] };
            currentRoundLog = { events: [], expectedPitchClasses: [0] };
            roundStartTime = null;  // This guard should prevent recording

            sessionLogRecordEvent('noteOn', 60, 100);

            assertEqual(currentRoundLog.events.length, 0, 'No events should be recorded');
        });

        test('sessionLogClear resets all state', () => {
            sessionLogEnabled = true;
            sessionLogSessions = [{ mode: 'test' }];
            currentSessionLog = { mode: 'test' };
            currentRoundLog = { events: [] };
            roundStartTime = Date.now();
            localStorage.setItem('sessionLogData', '[]');

            sessionLogClear();

            assertEqual(sessionLogSessions.length, 0);
            assertEqual(currentSessionLog, null);
            assertEqual(currentRoundLog, null);
            assertEqual(roundStartTime, null);
            assertEqual(localStorage.getItem('sessionLogData'), null);
        });

        test('Full session workflow', () => {
            resetState();
            sessionLogEnabled = true;

            // Start session
            sessionLogStartSession('chords', { rounds: 2 });
            assert(currentSessionLog !== null);

            // Round 1
            sessionLogStartRound({ prompt: 'C Major', requiredPitchClasses: new Set([0, 4, 7]) });
            sessionLogRecordEvent('noteOn', 60, 100);
            sessionLogRecordEvent('noteOn', 64, 100);
            sessionLogRecordEvent('noteOn', 67, 100);
            sessionLogEndRound({ responseTime: 1200, isFirstTry: true });

            // Round 2
            sessionLogStartRound({ prompt: 'G Major', requiredPitchClasses: new Set([7, 11, 2]) });
            sessionLogRecordEvent('noteOn', 55, 100);  // G
            sessionLogRecordEvent('noteOn', 58, 100);  // Wrong note! (Bb, pitch class 10)
            sessionLogRecordEvent('noteOn', 59, 100);  // B
            sessionLogRecordEvent('noteOn', 62, 100);  // D
            sessionLogEndRound({ responseTime: 1800, isFirstTry: false });

            // End session
            sessionLogEndSession();

            // Verify
            assertEqual(sessionLogSessions.length, 1);
            assertEqual(sessionLogSessions[0].rounds.length, 2);
            assertEqual(sessionLogSessions[0].rounds[0].events.length, 3);
            assertEqual(sessionLogSessions[0].rounds[1].events.length, 4);

            // Check wrong note was flagged
            const round2Events = sessionLogSessions[0].rounds[1].events;
            const wrongNote = round2Events.find(e => e.midi === 58);
            assertEqual(wrongNote.isCorrect, false, 'Wrong note should be flagged');

            // Check correct notes were flagged
            const correctNote = round2Events.find(e => e.midi === 55);
            assertEqual(correctNote.isCorrect, true, 'G should be correct');
        });

        // ==================== DISPLAY RESULTS ====================

        const resultsDiv = document.getElementById('results');
        const summaryDiv = document.getElementById('summary');

        let passCount = 0;
        let failCount = 0;

        results.forEach(r => {
            const div = document.createElement('div');
            div.className = `test ${r.status}`;

            if (r.status === 'pass') {
                div.textContent = `✓ ${r.name}`;
                passCount++;
            } else {
                div.innerHTML = `✗ ${r.name}<br><small style="opacity:0.8">${r.error}</small>`;
                failCount++;
            }

            resultsDiv.appendChild(div);
        });

        summaryDiv.className = `summary ${failCount === 0 ? 'all-pass' : 'has-fails'}`;
        summaryDiv.innerHTML = `
            <h2 style="margin-top:0">Summary</h2>
            <p><strong>${passCount}</strong> passed, <strong>${failCount}</strong> failed</p>
            ${failCount === 0
                ? '<p style="color:#4ade80">All tests passing! ✓</p>'
                : '<p style="color:#f87171">Some tests failed. Check the errors above.</p>'}
        `;
    </script>
</body>
</html>
